# ArrayList类API

## 单列集合特点总结:

### 	①Conllection根接口：既可以有序，也可以无序；既可以唯一，也可以重复

### 	②List接口：有序不唯一

### 	③ArrayList类：底层基于动态数组存储，具有初始容量为10；支持自动扩容，遵循1.5倍扩容机制

```java
// 实例化ArrayList类对象
public ArrayList<>();

// 增
// 在集合的结尾处追加
public boolean add(E e);

// 在集合的指定位置插入
public void add(int index,E e);

// 删
// 移除指定位置上的元素
public E remove(int index);

// 移除指定的元素（如果存在），当被移除的元素是数值型或字符型时，需要按照指定格式（(包装类)值）告诉虚拟机移除元素对象本身
public boolean remove(E e);

// 清空集合中的所有元素，但是保留集合结构
public void clear();

// 改
// 使用指定元素替换指定位置上的元素
public E set(int index,E e);

// 查
// 获取集合中元素的个数
public int size();

// 获取集合中指定位置上的元素
public E get(int index);

// 获取指定元素第一次出现的位置，如果不存在返回-1
public int indexOf(E e);

// 获取指定元素最后一次出现的位置，如果不存在返回-1
public int lastIndexOf(E e);

//判
// 判断指定的元素是否在集合中
public boolean contains(E e);
```

# Collections类 和 Arrays类

```java
// Arrays类
// 将一组散数据存储到List集合中
public static <T> List<T> asList(T... t);

// Collections类
// 对指定的List集合进行默认的升序排序
public static void sort(List<T> list);

// 获取指定单列集合中的最大值
public static T max(Collection<T> c);

// 获取指定单列集合中的最小值
public static T min(Collection<T> c);
```

# 泛型

## 格式：<任意一个大写字母>

## Java中常用的泛型字母

| 字母（符号） | 含义                                       |
| ------------ | ------------------------------------------ |
| T            | 表示Type -- Java中支持的任意一种数据类型   |
| K            | 表示KEY -- Map集合中的KEY                  |
| V            | 表示VALUE -- Map集合中的VALUE              |
| R            | 表示Result -- 一般用于方法返回值类型的泛型 |
| E            | 表示Element -- 一般用于集合泛型            |
| ?            | 表示任意一种不确定的数据类型               |

# 面试题：

# 1、简述数组中是否存在计算长度的方法？如果有，是什么？如果没有，数组怎样计算？

### 	数组中没有统计长度的方法，是通过数组名.length属性获取长度；

# 2、String类获取长度的方式是什么？

### 	String类是通过对象.length()获取长度；

# 3、集合获取长度的方式是什么？

### 	集合是通过集合对象名.size()获取长度



# 单列集合LinkedList类

# LinkedList类底层实现原理（重点记忆）

### 	基于双向链表存储，是List列表和Deque队列接口（是Queue接口的子接口）存储

# ArrayList类查询速度快，LinkedList类增删操作快

# 

# LinkedList类独有API

```java
public class LinkIsApiTest {
    public static void main(String[] args) {
        //实例化LinkedList类对象 => public LinkedList();
        LinkedList<Object> list = new LinkedList<>();
        /*
        * 增：
        *   public void addFirst(E e);
        *   在集合的头部追加元素，子弹往下压上膛，第一个子弹排到了最后一个位置上
        *   public void addLast(E e);
        *   在集合的尾部追加元素
        * */
        list.addFirst("85");
        list.addFirst("86");
        list.addFirst("96");
        list.addFirst("106");
        list.addFirst("116");
        list.addLast(789);//在尾部追加
        System.out.println("list ="+list);//list =[116, 106, 96, 86, 85, 789]
        System.out.println("❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀");
        /*
        * 删
        *   public E removeFirst();
        *   移除头部元素
        *   public E removeLast();
        *   移除尾部元素
        * */
        System.out.println(list.removeFirst());//116
        System.out.println(list.removeLast());//789
        System.out.println("❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀");
        /*
        * 查
        *   public E get getFirst();
        *   获取头部元素
        *   public E getLast();
        *   获取尾部元素
        * */
        System.out.println(list.getFirst());//106
        System.out.println(list.getLast());//85
    }
}
```

# Java中数据的存储方式

## 所谓的数据存储方式，实质上就是指集合中的元素在JVM虚拟机中的一个存取过程

## 分类:

### 	①队列式存储

### 	![image-20240711100409291](img\image-20240711100409291.png)

### ②堆栈式存储

![image-20240711100820951](img\image-20240711100820951.png)

## 面试题：

## 简述Java中数据存储的方式有哪些？特点是什么？底层如何实现？

### 	①队列式存储：先进先出，底层依赖于LinkedList类中的addFirst方法存数据，removeLast方法取数据

### 	②堆栈式存储：先进后出，底层依赖于LinkedList类中的addFirst方法存数据，removeFirst方法取数据

```java
自定义类实现堆栈式存储：
public class StackSave<T> {
    //由于存储方式底层依赖于Linkedlist，就需要将Linklist作为成员字段定义在当前类中
    private LinkedList<T> list;
    /* 声明了一个名为list的私有变量，其类型为LinkedList<T>。
     * 这里的T是一个泛型类型，表示这个链表可以存储任意类型的元素
     *
     * 分析：当且仅当StackSave对象创建是，LinkedList对象同时被创建
     * 伴生实例化:IO流
     *      👆在实例化的同时，另外一个对象也创建出来
     * */
    public StackSave(LinkedList<T> list) {
        this.list = list;
    }
    /*             👆
    * 接受一个泛型类型为T的LinkedList对象作为参数，
    * 并将其赋值给类的私有成员变量list。
    * 这样，StackSave类就可以使用传入的链表来实现栈的功能。
    * */
    //存数据
    public void save(T t) {
        list.addFirst(t);
    }
    /*             👆
    * 用于将元素t压入栈顶。
    * 由于LinkedList的特性，可以通过调用addFirst()方法
    * 将元素添加到链表的开头，从而实现栈的压入操作
    * */
    //取数据
    public T get(){
        return list.removeFirst();
    }
    /*             👆
    * 从栈顶取出元素。
    * 同样地，通过调用removeFirst()方法
    * 可以从链表的开头移除并返回元素，从而实现栈的弹出操作。
    * */
    //打印存储的数据
    public void print(){
        System.out.println(list);
    }
    //获取堆栈式存储空=空间内的元素个数
    public int getLength(){
        return list.size();
    }

}

```

```java
测试类：
public class StackSaveTest {
    public static void main(String[] args) {
        //实例化StackSave类对象
        StackSave<String> ss = new StackSave<>(new LinkedList<>());
        //通过StackSave对象调用方法保存数据
        ss.save("java58");
        ss.save("java59");
        ss.save("java60");
        ss.save("java61");
        ss.print();//[java61, java60, java59, java58]
        while(ss.getLength()>0){
           System.out.println(ss.get());
        }
        /*一个名为ss的StackSave<String>对象，
        * 并使用LinkedList<>作为底层数据结构。
        * 然后通过调用save方法向栈中添加了四个字符串元素：
        * "java58"、"java59"、"java60"和"java61"。
        * 接着调用print方法打印栈中的元素，输出结果为：
        * [java61, java60, java59, java58]。
        * 最后，使用while循环遍历栈中的所有元素，
        * 直到栈为空，每次循环都会调用get方法获取栈顶元素并打印出来。
        * java61
        * java60
        * java59
        * java58
        * */
    }
}
```

# 依赖注入的两种方式 => DI

## 1、有参构造器，给成员字段赋值

## 2、set方法



# 单列集合HashSet类

# 1、Set接口存储数据的特点：无序且唯一

# 2、两个实现类的底层原理

## HashSet类：基于哈希码值存储

## TreeSet类：基于二叉树存储

# 3、HashSet类API

```java
public class HashSetAppiTest {
    public static void main(String[] args) {
        //实例化HashSet类对象 => public HashSet()
        HashSet<Integer> set = new HashSet<>();
        //循环生成10次，随机数不重复，元素添加到set集合中
        /*for (int i = 0; i < 10; i++) {
            set.add((int) (Math.random() * 100));
        }
        会有漏洞，由于循环次数固定，无论是否出现重复元素
        只要循环10次，程序结束：想要的是只要元素不足10个，就一直随机生成存储
        因此使用while循环
        */
        while (set.size() < 10) {
            //当集合的大小小于10时，循环继续执行。
            set.add((int) (Math.random() * 100));
            //使用Math.random()函数生成一个0到1之间的随机浮点数，然后乘以100，再将结果转换为整数（通过强制类型转换）
        }
        System.out.println("set = " + set);
        System.out.println("max = " + Collections.max(set));
        System.out.println("min = " + Collections.min(set));

        //set = [4, 21, 71, 87, 72, 59, 27, 14, 94, 63]
        //max = 94
        //min = 4
    }
}
```

# 迭代器

# 用于获取无序集合中的指定元素技术

# 在JDK5版本开始，Java推出增强for循环（forEach循环）代替迭代器

![image-20240711111604087](img\image-20240711111604087.png)

# 迭代器执行原理 -- 游标指针

## 	所谓的游标指针（又称为游动标记指针）

## 	当程序通过迭代器对象调用hasNext方法时

## 	游标指针被创建，并准备启动，默认停在-1处；

## 	通过while循环根据hasNext方法的判断结果，

## 	进行不断的重复游动操作，进入到集合的范围内，

## 	通过next方法获取元素，并标记；

## 	直到所有的元素都被标记完成后，循环结束，游标指针回到-1处。

```java
/*
 * 需求：随机存储[0,100]范围内的10不重复元素，显示集合中[60,80]的所有元素
 * */
public class IteratorTest {
    public static void main(String[] args) {
        //抓娃娃机 👇
        HashSet<Integer> set = new HashSet<>();
        //娃娃             👇
        while (set.size() < 10) {
            set.add((int) (Math.random() * 100));
        }
        System.out.println("set =" + set);
        //抓娃娃的爪子  👇  ； 通过集合对象调用方法获取迭代器对象 -- public Iterator<T> iterator()
        Iterator<Integer> it = set.iterator();
        //摇杆 👇  ； 定义while循环，通过迭代器对象调用方法判断是否有元素 --public boolean hashNext
        while (it.hasNext()) {
            //按钮 👇 ； 通过迭代器对象调用方法获取元素 public T next()
            Integer num = it.next();
            if (num >= 60 && num <= 80) {
                System.out.println("num = " + num);
            }
        }
        //set =[80, 17, 2, 68, 36, 7, 41, 61, 14, 78]
        //num = 80
        //num = 68
        //num = 61
        //num = 78
    }
}
```

# 双列集合HashMap类

# Map集合（双列集合）存储数据的特点

## 以KEY-VALUE键值对形式存储,是一一对应的映射关系

## 其中KEY不能重复，对应的单列集合为Set；

## VALUE可以重复，对应的单列集合为Collection;



# 面试题：

# 简述Java中集合框架的分类，并阐述不同集合存储数据的特点和具体实现类底层实现原理

## 1、分类：单列集合 和 双列集合

## 2、存储数据特点

### 	①单列集合：

### 		Collection根接口：既可以重复，也可以唯一；既可以有序，也可以无序

### 		List接口：有序不唯一

### 		Set接口：无序且唯一

### 	②双列集合

### 		以KEY-VALUE键值对形式存储；是一一对应的映射关系；其中KEY不能重复，对应的单列集合为Set；VALUE可以重复，对应的单列集合为Collection

## 3、具体实现类底层实现原理

### 	①ArrayList类：基于动态数据存储，初始容量为10，支持自动扩容，按照1.5倍扩容

### 	②LinkedList类：基于双向链表存储

### 	③HashSet类：基于哈希码值存储

### 	④TreeSet类：基于二叉树存储

### 	⑤HashMap类：基于哈希码值存储

### 	⑥TreeMap类：基于二叉树存储

# HashMap类API

```java
/*
 * 构造器和put方法
 * */
public class HashMapApiTest {
    public static void main(String[] args) {
        //实例化HashMap类的对象 -- public HashMap()
        HashMap<String, String> map = new HashMap<>();
        /*
         * 增
         *   public V put(K key,V value)
         *   将一组指定的键值对存储到Map集合中
         *
         * 拓展：put方法如何存储数据？
         *  1、当KEY第一次存储的时候，返回值为null
         *  2、当KEY已存在时，再次存储，返回当前KEY对应的原有VALUE;
         *   并使用新的VALUE替换原有的值进行存储
         *  3、由于KEY对应SET集合，无序，因此随机显示数据
         *  4、VALUE的值可以重复
         *  注意！！！实际开发中，不会将put方法定义在打印语句中
         * */
        System.out.println(map.put("CH", "中国"));//null
        System.out.println(map.put("US", "美国"));//null
        System.out.println(map.put("CH", "中华人民共和国"));//中国
        System.out.println(map.put("GM", "德国"));//null
        System.out.println("❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀");
        System.out.println("map = " + map);//map = {CH=中华人民共和国, GM=德国, US=美国}
    }
}
```

## 其他方法

```java
public class HashMapApiTest_2 {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();
        map.put("张玲慧", "zlh");
        map.put("刘雨新", "lyx");
        map.put("张金", "zj");
        System.out.println("map = " + map);//map = {张玲慧=zlh, 刘雨新=lyx, 张金=zj}
        System.out.println("❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀");
        /*
         * 改：
         *   public V replace(K key,V newValue)
         *   使用指定的VALUE替换当前KEY的原有的VALUE（如果KEY存在）
         *
         *   public boolean repleace(K key,V oldValue,V new Value)
         *   当且仅当KEY与oldVlaue为键值对时，使用newValue替换
         * */
        map.replace("张玲慧", "张老汉");
        System.out.println("修改之后的map = " + map);//修改之后的map = {张玲慧=张老汉, 刘雨新=lyx, 张金=zj}
        map.replace("张玲慧", "张老汉", "张辛驰");
        System.out.println("修改之后的map = " + map);//修改之后的map = {张玲慧=张辛驰, 刘雨新=lyx, 张金=zj}
        System.out.println("❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀");
        /*
         * 查
         *   public int size()
         *   获取集合中键值对的个数
         *
         *   public V get (K key)
         *   根据指定的KEY来获取对应的VALUE（如果key存在）
         *
         *   public Set<K> keySet()
         *   获取所有key所在的Set集合
         *
         *   public Collection<V> values()
         *   获取所有VLAUE所在的Collection集合、
         * */
        System.out.println("map集合中键值对的个数：" + map.size());//map集合中键值对的个数：3
        System.out.println("张玲慧对应的VALUE：" + map.get("张玲慧"));//张玲慧对应的VALUE：张辛驰
        System.out.println("所有KEY所在的集合：" + map.keySet());//所有KEY所在的集合：[张玲慧, 刘雨新, 张金]
        System.out.println("所有VALUE所在的集合：" + map.values());//所有VALUE所在的集合：[张辛驰, lyx, zj]
        System.out.println("❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀");
        /*
         * 判
         *   public boolean containsKey(K key)
         *   判断指定的KEY是否是集合中的KEY
         *
         *   public boolean containsValue(V value)
         *   判断指定的VALUE是否是集合中的VALUE
         * */
        System.out.println("集合中是否存在张玲慧的KEY:" + map.containsKey("张玲慧"));//集合中是否存在张玲慧的KEY:true
        System.out.println("集合中是否存在张金的VALUE:" + map.containsValue("zj"));//集合中是否存在张金的VALUE:true
        System.out.println("❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀");
        /*
         * 删
         *   public void clear()
         *   清空集合中的所有键值对，但是保留集合中的结构
         *
         *   public V remove(K key)
         *   移除指定的KEY对应的value(如果KEY存在)
         *
         *   public boolean remove(K key,V value)
         *   当且仅当KEY和VAlUE是键值对关系时，才能移除
         * */
        map.remove("张玲慧");
        System.out.println("map = " + map);//map = {刘雨新=lyx, 张金=zj}
        map.remove("张玲慧", "实在是想不出来了");
        System.out.println("map = " + map);//map = {刘雨新=lyx, 张金=zj}
        map.clear();
        System.out.println("map = " + map);//map = {}
    }
}
```

# File类API（了解）

## 文件类，封装一组对计算机中指定文件操作的API

# 分类

## 1 、按照存储能力

### 	①文件：只能存储数据

### 	②文件夹：既能存储文件，也能存储子文件夹

## 2、 按照存储数据的类型

### 	①纯文本文件：只能存储字符数据；例如：.txt、.java......

### 	②媒体文件：既能存储字符，也能存储图片、视频、音频.......一般使用字节数据存储；例如：.md、.pdf......

```java
public static void main(String[] args) {
    //   实例化File类对象，并指定操作文件的路径
    //   public File (String filePath)
    /*
    * 注意！！！ 参数地址只是告诉JVM虚拟机，文件操作的位置，并不会在路径下创建文件
    *
    * 扩展：路径问题
    *   1、路径分类：
    *       相对路径：没有指定盘符
    *       绝对路径：指定盘符
    *   2、优缺点：
    *       绝对路径：优=>方便用户获取  缺=>在项目移植时，容器造成路径并不存在
    *       相对路径：优=>避免路径不存在的问题  缺=>用户获取比较麻烦
    *   3、实际开发中，推荐使用相对路径：将文件创建在当前的项目所在的文件夹下
    * */
    File file= new File("E://JAVA58//zlh.txt");
}
```

# ❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀

# 掌握LinkedList

## API

## 理解Java中数据存储方式

# 掌握HashSet类API

# 重点掌握HashMap类API

# 了解知道File类API

# 面试题

# 一阶段面试题：



# ![image-20240716183646852](E:\JAVA58\一阶段\面试题\img\image-20240716183646852.png)





# 简述DELETE语句和DROP语句的区别：

### ①DELETE语句：隶属于DML语句，当执行DELETE语句时，只会删除表中数据，保留表结构 

### ②DROP语句：隶属于DDL语句，当执行DROP语句时，会销毁表结构





# 简述常见的表约束有哪些？作用是什么？

![image-20240716184308786](E:\JAVA58\一阶段\面试题\img\image-20240716184308786.png)





# 简述Java中变量的含义和特点

### java中的变量是**程序中基本的数据存储单元**，它可以存储不同类型的数据，如整数、浮点数、布尔值等。

### 变量具有**动态性、类型性、作用域性等**特点。





![image-20240716190123487](E:\JAVA58\一阶段\面试题\img\image-20240716190123487.png)





![image-20240716190142629](E:\JAVA58\一阶段\面试题\img\image-20240716190142629.png)

![image-20240716190153752](E:\JAVA58\一阶段\面试题\img\image-20240716190153752.png)





![image-20240716185958580](E:\JAVA58\一阶段\面试题\img\image-20240716185958580.png)





![image-20240716190215327](E:\JAVA58\一阶段\面试题\img\image-20240716190215327.png)







![image-20240716190400902](E:\JAVA58\一阶段\面试题\img\image-20240716190400902.png)







![image-20240716190416249](E:\JAVA58\一阶段\面试题\img\image-20240716190416249.png)





![image-20240716190429707](E:\JAVA58\一阶段\面试题\img\image-20240716190429707.png)





![image-20240716190447852](E:\JAVA58\一阶段\面试题\img\image-20240716190447852.png)







![image-20240716190505197](E:\JAVA58\一阶段\面试题\img\image-20240716190505197.png)

![image-20240716190519608](E:\JAVA58\一阶段\面试题\img\image-20240716190519608.png)





![image-20240716190821276](E:\JAVA58\一阶段\面试题\img\image-20240716190821276.png)





![image-20240716190837897](E:\JAVA58\一阶段\面试题\img\image-20240716190837897.png)





![image-20240716190855572](E:\JAVA58\一阶段\面试题\img\image-20240716190855572.png)







![image-20240716190911870](E:\JAVA58\一阶段\面试题\img\image-20240716190911870.png)

![image-20240716190922028](E:\JAVA58\一阶段\面试题\img\image-20240716190922028.png)





![image-20240716190953681](E:\JAVA58\一阶段\面试题\img\image-20240716190953681.png)





![image-20240716191007698](E:\JAVA58\一阶段\面试题\img\image-20240716191007698.png)





![image-20240716191146778](E:\JAVA58\一阶段\面试题\img\image-20240716191146778.png)

![image-20240716191208378](E:\JAVA58\一阶段\面试题\img\image-20240716191208378.png)





![image-20240716191241854](E:\JAVA58\一阶段\面试题\img\image-20240716191241854.png)





![image-20240716191254954](E:\JAVA58\一阶段\面试题\img\image-20240716191254954.png)





![image-20240716191428400](E:\JAVA58\一阶段\面试题\img\image-20240716191428400.png)

![image-20240716191448998](E:\JAVA58\一阶段\面试题\img\image-20240716191448998.png)





![image-20240716191503092](E:\JAVA58\一阶段\面试题\img\image-20240716191503092.png)





![image-20240716191515550](E:\JAVA58\一阶段\面试题\img\image-20240716191515550.png)





![image-20240716191529096](E:\JAVA58\一阶段\面试题\img\image-20240716191529096.png)





![image-20240716191705536](E:\JAVA58\一阶段\面试题\img\image-20240716191705536.png)

![image-20240716191715269](E:\JAVA58\一阶段\面试题\img\image-20240716191715269.png)





![image-20240716191739280](E:\JAVA58\一阶段\面试题\img\image-20240716191739280.png)





![image-20240716191752041](E:\JAVA58\一阶段\面试题\img\image-20240716191752041.png)







![image-20240716191840427](E:\JAVA58\一阶段\面试题\img\image-20240716191840427.png)





![image-20240716191855123](E:\JAVA58\一阶段\面试题\img\image-20240716191855123.png)





![image-20240716191908228](E:\JAVA58\一阶段\面试题\img\image-20240716191908228.png)

![image-20240716191926724](E:\JAVA58\一阶段\面试题\img\image-20240716191926724.png)





![image-20240716191946519](E:\JAVA58\一阶段\面试题\img\image-20240716191946519.png)





![image-20240716191959494](E:\JAVA58\一阶段\面试题\img\image-20240716191959494.png)







# 简述为什么在重写equals方法时，重写hashCode方法？

### 	为了提高equals方法比较效率





# 简述==与equals方法区别

### 	①==：只能进行栈内存比较

### 		当比较的是基本数据类型时，比较值是否一致

### 		当比较的是引用数据类型时，比较对象地址是否一致

### 	②equals方法：只能进行引用数据类型比较

### 		当子类没有重写equals方法时，调用的是Object类中的方法，与==一致，比较的是栈内存对象地址是否一致

### 		当子类重写equals方法时，则比较堆内存中存储的数据值是否相等





# 	基本数据类型对应包装类

| 基本数据类型 | 包装类    |
| ------------ | --------- |
| byte         | Byte      |
| short        | Short     |
| int          | Integer   |
| long         | Long      |
| float        | Float     |
| double       | Double    |
| char         | Character |
| boolean      | Boolean   |

### 	包装类、基本数据类型、String类型相互转换方式

### 		注意！！！！

### 			String转换成数值型数据时，其值必须是数字

### 			String不能转换成char/Character





#  简述String类为什么是不可变？

### 	①底层依赖于char[]存储，数组一旦创建长度固定

### 	②由于String类定义结构使用final修饰，结构稳定





# 简述append方法和 + 都能够实现字符串的尾部追加操作，区别是什么？

### 	操作数据的位置不同

### 	①append方法：操作的是缓冲区中的数据

### 	②+：操作的是堆栈内存中的数据





# 简述String、StringBuffer、StringBuilder类的相同点

### 	①String、StringBuffer、StringBuilder类的相同点

### 		Ⅰ 都是用来操作字符串的类

### 		Ⅱ 类的定义结构都被final修饰，结构稳定

### 	②String、StringBuffer共同点

### 		Ⅰ 都是多线程操作安全

### 		Ⅱ 都是在JDK1.0版本开始应用

### 	③StringBuffer、StringBuilder类的相同点

### 		Ⅰ 都是操作缓冲区的类

### 		Ⅱ 都是可变长度字符串

### 	④String类特点：操作堆栈内存，长度固定

### 	⑤StringBuilder类特点：是JDK5版本开始应用，是单线程操作，更快捷





# 简述Java中数据存储的方式有哪些？特点是什么？底层如何实现？

### ①队列式存储：先进先出，底层依赖LinkList类，addFirst方法存数据，removeLast取数据

### ②堆栈式存储：先进后出，底层依赖LinkedList类，addFirst方法存储据，removeFirst取数据





# 简述Java中集合框架结构的分类？并说明不同集合的存储特点，以及底层具体实现类是如何实现？

### ①分为：单列集合 和 双列集合

### ②存储数据特点：

## 单列集合：

### 	Collection根接口：又重复，又唯一；又有序，又无序

### 	List接口：有序不唯一

### 	Set接口：无序且唯一

### 	Queue接口：先进先出

## 双列集合：

### 	以KEY-VALUE键值对形式存储,是一一对应的映射关系

### 	其中KEY不能重复，对应的单列集合为Set；

### 	VALUE可以重复，对应的单列集合为Collection;

### ③ 具体实现类底层实现原理

### 		ArrayList类：基于动态数据存储，初始容量为10，支持自动扩容，按照1.5倍扩容

### 		LinkedList类：基于双向链表存储

### 		HashSet类：基于哈希码值存储

### 		TreeSet类：基于二叉树存储

### 		HashMap类：基于哈希码值存储

### 		TreeMap类：基于二叉树存储





# 简述数组中是否存在计算长度的方法？如果有，是什么？如果没有，数组怎样计算？String类获取长度的方式是什么？集合获取长度的方式是什么？

## 	数组中没有统计长度的方法，是通过数组名.length属性获取长度；String类是通过对象.length()获取长度；集合是通过集合对象名.size()获取长度





# 简述java中IO流的分类和具体实现类

## 1、按照流向分为：输入流、输出流

## 2、按照操作数据的类型分

### 			字符流：

### 				1）字符输入流：Reader => FileReader和BufferedReader

### 				2）字符输出流：Writer => FileWriter和BufferWriter

### 			字节流：

### 				1) 字节输入流：InputStream => FileInputStream和BufferedInputStream

### 			    2)字节输出流：OutputStream => FileOutputStream和BufferedOutputStream





# 简述在流资源中是否所有的高效流都提供高效方法?如果提供，请说出是哪些方法，并说明作用?如果没有提供，为什么还要使用高效流?

### 并不是所有的高效流都提供高效方法;只有字符高效流提供，其中字符输出高效流，提供newLine方法，实现跨平台换行操作，字符输入高效流，提供readLine方法，读取一行数据;之所以使用高效流，因为高效流操作缓冲区一定程度上降低堆栈内存的损耗





# 简述java中的序列化和反序列化

### 序列化：使用指定的技术，将对象中的数据上传到指定的文件中或网络地址上

### 反序列化：使用指定的技术，将文件中的数据或网络地址中的数据下载到指定的对象中





# 如何实现序列化和反序列化

## 指定技术：序列化的过程就是对数据的写操作

##                   				反序列化的过程就是对数据的读操作

## 因此使用IO流中*对象字节流*的技术

## 序列化：上传数据，将对象中的数据写入到指定文件或网络地址上 => ObjectOutputStream类

## 反序列化：下载数据，将指定文件或网络地址中的数据读取到对象中 => ObjectInputStream类





# 什么是并行和并发？

## 并发：单核，数据量较小操作，按照顺序执行

## 并行：多核，数据量较大的操作，随机执行



# 简述Java中多线程的创建方式有哪些？

## 创建方式：继承Thread类、实现Runnable接口、实现Callable接口

# 如何开启多线程操作？

## 如何开启多线程：通过Thread类中的start方法开启多线程

# 不同方式的优缺点是什么？

### 	①继承Thread类

### 		Ⅰ 优点：由于是继承关系，可以直接调用Thread类中的方法

### 		Ⅱ 不足：会提高类与类之间的耦合度

### 	②实现Runnable接口和实现Callable接口

### 		Ⅰ 优点：避免Java中单继承的局限性，降低类与类之间的耦合度

### 		Ⅱ 不足：在执行多线程之前需要与Thread类先建立关联

# 		实际开发中更推荐哪种？

### 		实际开发中，需要根据用户的实际需求具体问题具体分析；但更多使用实现接口操作



# 简述Java中线程的状态有哪些？处于不同状态下的线程具备什么权限？

| 线程状态         | 具备的权限                 |
| ---------------- | -------------------------- |
| 创建状态         | 只有生存权                 |
| 运行状态         | 既有生存权，也有执行权     |
| 消亡状态         | 既没有生存权，也没有执行权 |
| 临时（阻塞）状态 | 只有生存权，没有执行权     |



# 简述创建状态和阻塞状态下的生存权区别是什么？

### 	区别在于创建状态多线程并没有被开启，而阻塞状态是多线程被开启，没有“抢到”CPU的执行权



# 处于阻塞状态下的线程存储位置？进出原则？

### 	由JVM虚拟机提供的线程池中，按照先进先出的原则



# 简述Java中使用同步解决多线程代码安全隐患问题的方式有哪些？区别是什么？

## 方式：同步代码块 和 同步函数

## 区别："锁"不同

### 	①同步函数：只支持本类对象锁（即this）

### 	②同步代码块：支持任意对象锁（即Object对象）、本类对象锁（即this）、反射机制锁（即类名.class（推荐使用））



# 拓展：使用同步函数和同步代码块各自优缺点（理解）

## 1、同步代码块

### 	①优点：支持”锁“的种类较多，直接定义在run方法中，不会忘记调用

### 	②不足：由于直接定义在run方法中，但是使run方法业务逻辑复杂

## 2、同步函数

### 	①优点：由于自定义同步函数，使调用（run方法）和业务逻辑（同步函数）分离，降低耦合度

### 	②不足：由于同步函数单独定义，有时可能忘记在run方法中调用，排错性较差

# 

# 简述Sleep方法和wait方法的异同点：

### 相同点:当线程执行到sleep方法或wait方法时，都不会继续向后执行，由运行状态转为阻塞状态，进入到线程池中存储

### 不同点:sleep方法:到时自动醒来，但是不会释放锁对象wait方法:需要配合指定方法进行手动唤醒，但是会释放锁对象


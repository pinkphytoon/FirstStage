# 复习

## 字节流API

```java
// 字节输出流
// 实例化FileOutputStream类对象
public FileOutputStream(String fileName);

/*
	写一组方法 -- 可以直接写入到指定的文件中
	一般配合使用String类提供的方法
	public byte[] getBytes();
*/
public void write(byte[] bbuf);

// 关闭资源的操作
public void close();

// 实例化BufferedOutputStream类对象
public BufferedOutputStream(OutputStream out);

// 由于高效流操作缓冲区，因此需要进行数据刷新
public void flush();

// 字节输入流
// 实例化FileInputStream类对象
public FileInputStream(String fileName);

/*
	读一组方法
	一般配合String类构造器使用
	public String(byte[] bbuf,int beginIndex,int length)
*/
public int read(byte[] bbuf);

// 关闭资源的操作
public void close();

// 实例化BufferedInputStream类对象
public BufferedInputStream(InputStream in);
```



# 理解转换流

## 字符转字节：OutputStreamWriter

## 字节转字符：InputStreamReader



# 序列化和反序列化

```java
// JavaBean中实现序列化和反序列化操作
public class 类名 implements Serializable{
    // 按照Java规范的格式设置默认序列化号
    public static final long serialVersionUID = 1L;
    
    按照JavaBean规范定义类
}
```



# 面试题

## 简述java中流资源的分类，必能简述不同流资源的具体实现类有哪些？

### ①流向分：输入流和输出流

### ②操作数据类型：

#### 		字符输出流：Writer => FileWriter/BufferedWriter

#### 		字符输入流：Reader => FileReader/BufferedReader

#### 		字节输出流:OutputStream => FileOutputStream/BufferedOutputStream

#### 		字节输入流:InputStream => FilelnputStream/BufferedInputStream



# 面试题

## 简述是否所有的高效流都提供高效方法?如果提供，简述方法的作用;如果没有提高为什么还要使用高效流?

### 不是所有的高效流都提供高效方法;只有字符高效流提供，其中字符输出高效流提供newLine方法，表示跨平台的换行操作;字符输入高效流提供readLine方法，表示读取一行数据;之所以使用高效流，由于高效流操作的都是缓冲区，一定程度上降低堆栈内存的损耗



# 面试题

## 简述什么是序列化和反序列化

### 	①序列化：使用指定的技术将对象中的数据上传到指定的文件中或网络地址上

### 	②反序列化：使用指定的技术将文件中或网络地址上的数据下载到指定对象中

# ==================================

# 多线程的概述

## java特点：

### 完全面向对象 — 核心编程思想

### 简单 — 具有固定的语法格式 和 统一编码规范

### 跨平台 — 增强java语言的兼容性，在不同的操作系统下安装JDK，可进行java开发

### 健壮 — 编程语言的安全性

### 多线程 — 提高工作效率，考虑数据安全问题



# 多线程名词：

## 线程：控制进程执行的最小单位

## 进程：硬件设备每一个可运行的程序

## 单线程：一个进程中只包含一个线程（收音机~）

## 多线程：一个进程中至少包含两个或两个以上的线程

## 线程与进程的关系：进程包含线程

## 包含：

#### 	①主线程：主函数  =>  in thread "main" 其中thread表示线程，"mian"表示主线程的名字

#### 	②JVM垃圾回收处理（GC）



# 面试题：什么是并行和并发？

## 并发：单核，数据量较小操作，按照顺序执行

## 并行：多核，数据量较大的操作，随机执行



# 多线程的创建方式！！！

## 三种：

### 1、创建类继承Thread类 — Thread类是java定义好的一个专门用于执行多线程操作的类（所有的API都定义在该类中）

### 2、创建类实现Runnable接口 — 避免单继承的局限性，需要与Thread类建立关联

### 3、创建Callable接口—进阶



# 多线程操作的核心思想：

## 在同一时刻有多个线程操作共同资源（同一资源），每次操作完成后的结果都不固定

# --------------------

# 继承Thread类核心原理：

## 创建类继承Thread类，一定重写Thread类中的run方法<u>*（目的：在run方法中变成编程操作共同资源的多线程代码）*</u>，测试类中通过调用start方法，开启多线程，调用重写run方法

### ①创建类继承Thread类

```java
public class SonThread extends Thread {
    //名为SonThread的类，它继承了Java中的Thread类
    //重写run方法 —— 该方法是线程执行的主要逻辑
    @Override
    public void run() {
        //打印[0,100]的所有元素
        for (int i = 0; i < 100; i++) {
            System.out.println("SonThread ::" + i);
        }
    }
}
```

### ②测试类

```java
/*
 * 测试类
 * */
public class SonThreadTest {
    public static void main(String[] args) {
        //实例化Thread子类的对象
        SonThread st = new SonThread();
        //通过子类对象调用start方法，开启多线程，并调用重写的run方法
        st.start();
        //打印[0,100]所有的元素
        for (int i = 0; i < 100; i++) {
            System.out.println("SonThread ::" + i);
        }
    }
}
```

### 	通过上述代码测试，当调用start方法时会开启多线程执行，并调用重写run方法；每次执行的结果不固定；原因是多个线程共同“抢占”CPU的执行权，谁抢到，谁执行

# 	继承Thread的优劣势：

### 优势：由于和Thread类是继承关系，所以可以调用父类中的方法，操作数据

### 缺点：耦合度高

# -----------------------------

# 实现Runnable接口

## 创建类实现Runnable接口，重写接口中的run方法，在测试类中，实例化Runnable实现类对象，与Thread类建立关联，在通过Thread类对象调用start方法，进行多线程的操作

### ①创建类实现Runnable接口

```java
public class SonRunnableImpl implements Runnable {
    @Override
    public void run() {
        //打印[0,100]所有元素
        for (int i = 0; i < 100; i++) {
            System.out.println("SonRunnableImpl::" + i);
        }
    }
}
```

### ②测试类

```java
public class SonRunnableImplTest {
    public static void main(String[] args) {
        //实例化Runnable接口实现类对象 —— 称之为面向接口编程
        Runnable r = new SonRunnableImpl();
        //👆这个接口 名 = new  刚才创建的SonRunnableImpl类
        /*
         * 建立Runnable接口对象和Thread类对象的关联
         * 通过Thread类构造器完成
         * public Thread(Runnable r)
         * */
        Thread thread = new Thread(r);
        //创建一个新的线程并将Runnable对象传递给他，通过Thread类对象调用start方法开启多线程操作
        thread.start();
        //启动线程，它将调用Runnable对象的run()方法
        for (int i = 0; i < 100; i++) {
            //打印[0,100)所有元素
            System.out.println("main :: " + i);
        }
    }
}
```

![image-20240715201355376](E:\JAVA58\一阶段\0715\img\image-20240715201355376.png)

### ③优缺点

### 	优点：降低类与类的之间的耦合度

### 	缺点：需要先建立与Thread的关联，才能操作多线程

# ---------------------------

# 面试题：

# 简述Java中多线程的创建方式有哪些？

## 创建方式：继承Thread类、实现Runnable接口、实现Callable接口



# 如何开启多线程操作？

## 如何开启多线程：通过Thread类中的start方法开启多线程



# 不同方式的优缺点是什么？

### 	①继承Thread类

### 		Ⅰ 优点：由于是继承关系，可以直接调用Thread类中的方法

### 		Ⅱ 不足：会提高类与类之间的耦合度

### 	②实现Runnable接口和实现Callable接口

### 		Ⅰ 优点：避免Java中单继承的局限性，降低类与类之间的耦合度

### 		Ⅱ 不足：在执行多线程之前需要与Thread类先建立关联



# 		实际开发中更推荐哪种？

### 		实际开发中，需要根据用户的实际需求具体问题具体分析；但更多使用实现接口操作

# ---------------------

# 掌握Thread类API ！！！

```java
//无参构造器
public Thread();

//有参构造器，主要用于Runnable接口对象建立关联
public Thread(Runnable r);

//有参构造器，主要用于Callable接口对象建立关联
public Thread(Callable c);

//多线程操作代码
public void run();

//开启多线程并调用指定run方法执行
public void start();
```

## 代码实现：

```java
public class SonRunnableImpl implements Runnable {
    @Override
    public void run() {
        Thread t = Thread.currentThread();
        //父类的引用指向子类对象 - 多态
        t.setName("张金吃屁");
        /*
         * public int getPriority();
         * 获取当前线程的执行的优先级
         * java为每一个线程设置默认的优先级为5
         *
         * public void getPriority(int newgetPriority)
         * 设置当前线程的优先级
         * 优先级取值范围在[1,10]区间内，其中1最大，10最小
         *
         * 注意：是设置优先级提高被优先分配的可能，由CPU分配执行权
         *       并不是优先级越高，就先被执行完滴！！！
         * */
        t.setPriority(10);
        System.out.println("当前线程的优先级：" + t.getPriority());
        //打印[0,100)所有元素
        for (int i = 0; i < 100; i++) {
            /*
             * Thread类提供的API：
             *   public static Thread currentThread();
             *   获取当前线程对象！！！！！！！！！！！！！！！！！！！
             *
             *   public String getName();
             *   获取当前线程的名字
             *   java会给每个线程按照格式创建默认的名字
             *   格式：Thread-N (N从0开始)
             * */
            System.out.println(t.getName() + "::" + i);
        }
    }
}
```

```java
public class SonRunnableImplTest {
    public static void main(String[] args) {
        Runnable r = new SonRunnableImpl();
        Thread thread = new Thread(r);
        thread.start();
        for (int i = 0; i < 100; i++) {
            System.out.println("main :: " + i);
        }
    }
}
```

![image-20240715204233068](E:\JAVA58\一阶段\0715\img\image-20240715204233068.png)





# 多线程的原理:

## ![image-20240715114713784](E:\JAVA58\一阶段\0715\img\image-20240715114713784.png)

# 面试题

# 简述Java中线程的状态有哪些？处于不同状态下的线程具备什么权限？

| 线程状态         | 具备的权限                 |
| ---------------- | -------------------------- |
| 创建状态         | 只有生存权                 |
| 运行状态         | 既有生存权，也有执行权     |
| 消亡状态         | 既没有生存权，也没有执行权 |
| 临时（阻塞）状态 | 只有生存权，没有执行权     |

# 简述创建状态和阻塞状态下的生存权区别是什么？

### 	区别在于创建状态多线程并没有被开启，而阻塞状态是多线程被开启，没有“抢到”CPU的执行权

# 处于阻塞状态下的线程存储位置？进出原则？

### 	由JVM虚拟机提供的线程池中，按照先进先出的原则

# -----------------------------

# 等待唤醒机制

## 解决问题：实现多线程在运行状态和堵塞状态相互转换的问题；JDK5版本开始,JAVA 提出Lock锁接口代替



# 由Object类提供方法

```java
//让当前线程处于等待状态
public void wait();

//唤醒当前线程
public void notify();

//唤醒线池所有处于等待状态下的线程（常用）
public void notifyAll();
```

# 为什么等待唤醒机制的操作定义在Object类中，而没有定义在Thread类中？

## 由于java语言是多线程的编程语言，也就意味着使用java语言编写的类都是有可能被等待唤醒，因此等待唤醒的方法就是共性方法，需要定义在父类中，而实际开发中，并不是所有的类都会继承Thread,但是只要是java语言编写的类，默认会继承Object类或是Object类的间接子类，java才会将等待唤醒机制的方法定义在Object类

# ------------------------

# 多线程代码安全隐患问题和解决办法

## 需求：定义3个窗口（线程）共同去售卖150张牌（共同资源）

# 分析多线程的安全隐患的前提是：

## 程序必须是多线程操作

## 多个线程必须操作同一共同资源

### ①创建类实现Runnable接口，编写卖票的操作

```java
public class SaleWindow implements Runnable {
    //定义初始票总数
    private int tick = 150;
    
    @Override
    public void run() {
        //由于不知道多长时间能够买完，因此使用while循环
        while (true) {
            //当且仅当tick>0时，可以售卖
            if (tick > 0) {
                /*
                 * 通过Thread类调用sleep方法，模拟出牌过程
                 * public static void sleep(long millis)
                 * 参数表示让当前线程睡眠指定毫秒数
                 * */
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "::" + tick--);
                //票数先操作，之后在减1
            } else {
                System.out.println("sorry,not tick now");
                break;
            }
        }
    }
}
```

### ②测试类

```java
public class SaleWindowTest {
    public static void main(String[] args) {
        //实例化Runnable接口对象
        Runnable r = new SaleWindow();
        //分别创建三个线程对象，与Runnable接口对象建立关联
        Thread w0 = new Thread(r);
        Thread w1 = new Thread(r);
        Thread w2 = new Thread(r);
        //通过不同的线程对象调用start方法
        w0.start();
        w1.start();
        w2.start();
    }
}
```

![image-20240715210431196](E:\JAVA58\一阶段\0715\img\image-20240715210431196.png)

# 会有重复票或者错票的问题，这是为啥？

# 原因：

### 当进行多线程操作时，一个线程”抢占“CPU执行权操作时，中途其他的线程也可以操作共同资源，当进入到堵塞状态时，没有完成操作的线程，会睡眠；此时其他线程进行操作

# 解决办法：

### 当一个线程在操作共同资源前，需要对共同资源进行 “上锁” ，在进行线程操作；此时其他线程因为没有获取🔑，即使抢到CPU的执行权，也无法操作共同资源，只有在锁内操作完成后释放🔒，其他线程才能执行操作





# 技术：同步 ”锁“ 

## 专业术语：旗标🔒

### 由java语言定义好的修饰符（关键字）-  synchronized同步的

## synchronized修饰符

### 1、含义：同步的

### 2、能够修饰：代码块和方法

### 3、特点：为当前线程操作”上锁“，保证线程操作安全性



# 分别使用同步代码块和同步函数解决多线程代码安全隐患问题

## 同步代码块

### 1、定义位置：在run 方法中，在操作共同资源代码前

### ①售票窗口类

```java
public class SaleWindow implements Runnable {
    //定义初始票总数
    private int tick = 150;

    //创建Object类对象 —— 针对于详解中的任意对象锁👇
    //Object obj = new Object();
    @Override
    public void run() {
        //由于不知道多长时间能够买完，因此使用while循环
        while (true) {
            /*
             * 同步代码块
             * synchronized(对象){
             * 操作共同资源的代码
             * }
             * 详解：对象 —— 可以传递锁的类型，三种
             *       1、任意对象锁：即Object类对象锁——不推荐使用，需要单独去chain关键Object类对象，造成内存浪费
             *       2、本类对象锁：this关键字锁
             *       3、反射机制锁：通过获取当前类的字节码文件对象（推荐使用）———类名.class
             *
             * */
            synchronized (SaleWindow.class) {
                //当且仅当tick>0时，可以售卖
                if (tick > 0) {
                    /*
                     * 通过Thread类调用sleep方法，模拟出牌过程
                     * public static void sleep(long millis)
                     * 参数表示让当前线程睡眠指定毫秒数
                     * */
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + "::" + tick--);
                    //票数先操作，之后在减1
                } else {
                    System.out.println("sorry,not tick now");
                    break;
                }
            }
        }
    }
}
```

### ②测试类

```java
public class SaleWindowTest {
    public static void main(String[] args) {
        //实例化Runnable接口对象
        Runnable r = new SaleWindow();
        //分别创建三个线程对象，与Runnable接口对象建立关联
        Thread w0 = new Thread(r);
        Thread w1 = new Thread(r);
        Thread w2 = new Thread(r);
        //通过不同的线程对象调用start方法
        w0.start();
        w1.start();
        w2.start();
    }
}
```

![image-20240715211519445](E:\JAVA58\一阶段\0715\img\image-20240715211519445.png)



## 同步函数

### 1、定义位置：在多线程实现类中自定义方法，该方法必须被synchronized关键修饰，将操作共同资源的代码定义在该方法中，千万不要忘记在run方法中调用 自定义的同步函数



# 面试题：简述 java中同步解决多线程代码安全隐患问题的方式有哪些？区别？

## 方式：同步代码块和同步函数

## 区别：🔒不同

### 		1、同步函数：只支持本类对象锁（this）

### 		2、同步代码块：支持任意对象锁（Object对象）、本类对象锁（this）、反射机制锁（类名.class）



# 拓展：使用同步函数和同步代码块各自优缺点

## 同步代码块

### 优：支持🔒的种类较多，直接定义在run方法中，不会忘记调用

### 缺：由于直接定义在run方法中,但是run方法业务逻辑复杂

```java
public class SaleWindowByMenthod implements Runnable {
    private int tick = 150;

    @Override
    public void run() {
        //提问：同步函数的🔒是？
        //  本类对象锁 => this关键字
        this.show();
        /*
         * 千万不要忘记在run方法中调用自定义的同步函数
         * 因为通过start方法开启多线程，只能调用run方法，而多线程操作
         * 定义在自定义的同步函数中，因此千万在run方法中调用
         * */
    }
    //自定义同步操作方法
    public synchronized void show() {
        while (true) {
            if (tick > 0) {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "::" + tick--);
            } else {
                System.out.println("sorry,not tick now");
                break;
            }
        }
    }
}
```

```java
public class SaleWindowByMethodTest {
    public static void main(String[] args) {
        Runnable r = new SaleWindowByMenthod();
        Thread w0 = new Thread(r);
        Thread w1 = new Thread(r);
        Thread w2 = new Thread(r);
        w0.start();
        w1.start();
        w2.start();
    }
}
```

![image-20240715214955703](E:\JAVA58\一阶段\0715\img\image-20240715214955703.png)



# 面试题：简述Java中使用同步解决多线程代码安全隐患问题的方式有哪些？区别是什么？

## 方式：同步代码块 和 同步函数

## 区别："锁"不同

### 	①同步函数：只支持本类对象锁（即this）

### 	②同步代码块：支持任意对象锁（即Object对象）、本类对象锁（即this）、反射机制锁（即类名.class（推荐使用））



# 拓展：使用同步函数和同步代码块各自优缺点（理解）

## 1、同步代码块

### 	①优点：支持”锁“的种类较多，直接定义在run方法中，不会忘记调用

### 	②不足：由于直接定义在run方法中，但是使run方法业务逻辑复杂

## 2、同步函数

### 	①优点：由于自定义同步函数，使调用（run方法）和业务逻辑（同步函数）分离，降低耦合度

### 	②不足：由于同步函数单独定义，有时可能忘记在run方法中调用，排错性较差

# =====================

# 今日回顾

# 1 重点掌握多线程创建方式

# 2 掌握Thread类API

# 3 理解如何分析 + 解决多线程代码安全隐患问题

# 4 面试题








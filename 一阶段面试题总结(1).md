## 1 简述Java变量的含义和特点

## 答：

## 	含义：一个数据存储空间的表示

## 	特点：唯一性、随机性

## 2 简述Java中数据类型定义的关键字有哪些？默认值是什么？

## 答：

| 引用数据类型 -- String、数组、接口 -- null |
| ------------------------------------------ |
| 基本数据类型                               |
| 数值型                                     |
| 整数型：byte、short、int（0）、long        |
| 浮点型（小数）：float、double（0.0）       |
| 字符型：char -- 空格                       |
| 布尔型：boolean -- false                   |

## 3 简述/和%的适用场景

## 答：当判断两个数的关系时，推荐使用%；其余情况按照需求使用

## 4 简述x++与++x的区别

## 答：

## 	当作为单条语句编写时，x++与++x没有区别

## 	当作为组合语句编写时，

### 		x++：先执行操作，操作结束后，再自身+1

### 		++x：先自身+1，再执行操作

## 5 简述&（按位与）与&&（逻辑与，或短路与）的区别

## 答：当当前表示能够判断出整体表达式的结果时，&&只运行当前表达式，&会执行所有的表达式

## 6 if...else语句与条件运算符的适用场景

## 答：

### 	当根据条件判断后，还需要进行其他的代码操作时，推荐使用if...else语句

### 	当根据条件判断后，直接显示操作结果时，推荐使用条件运算符

## 7 if...else if与switch的异同点和适用场景

## 答：

### 	相同点：

### 		都是进行多个条件选择判断

### 		都能够使用}作为结束标志

### 	不同点：

### 		if...else if：条件为任意的关系表达式或逻辑表达式，结果一定是boolean类型；既可	以判断范围，也可以进行等值判断

### 		switch：条件只能为等值表达式，结果必须满足byte、short、char、int、String五	种类型中的任意一种；只能进行等值判断；还可使用break作为结束标志

### 	适用场景：当条件为等值表达式，且值满足指定的5种类型，且值的结果可能性较少时，推荐使用switch语句，效率稍高

## 8 while循环与do...while循环的区别

## 答：

### 	while循环：先判断，再执行

### 	do...while循环：先执行一次，再判断

## 9 for循环与while循环的区别和适用场景

## 答：

### 	区别：相同条件下，for比while更节省栈内存空间

### 	适用场景：

### 		已知循环次数使用for

### 		未知循环次数使用while

## 10 双重for循环的特点

## 答：

### 	外循环控制行，内循环控制列

### 	外循环执行一次，内循环执行一遍

## 11 简述你使用过的结束操作有哪些？作用是什么？

## 答：

| 结束操作 | 作用                                                         |
| -------- | ------------------------------------------------------------ |
| }        | 表示代码块结束                                               |
| ;        | 表示一条语句结束                                             |
| break    | 终止语句，结束流程控制语句；执行到break，流程控制语句结束，对switch和所有的循环语句起作用 |
| continue | 中断语句，结束流程控制语句；执行到continue，结束本次，执行下一次，只对所有的循环语句起作用 |
| return   | 返回，结束有返回值类型的方法；可以定义多次，但是只能返回一个；表示方法结束，其后不能定义任何的功能代码 |

## 12 简述你熟悉的JVM虚拟机中的内存空间？并简要说明起作用？

## 答：

| JVM虚拟机内存空间 | 作用                                                         |
| ----------------- | ------------------------------------------------------------ |
| 栈内存            | 存储基本数据类型、引用数据类型的声明、方法的调用             |
| 堆内存            | 通过new关键字实例化的引用数据类型和数组中数据的存储          |
| 垃圾回收处理      | JVM认为当前的内存不足以支持程序运行时，会自动启动，处理内存空间中无效数据 |

## 13 方法重写（Override）与重载（Overload）的对比

| 比较项     | 方法重写（Override）         | 方法重载（Overload）             |
| ---------- | ---------------------------- | -------------------------------- |
| 定义位置   | 子类                         | 本类                             |
| 方法名     | 一致                         | 一致                             |
| 参数列表   | 一致                         | 不同（个数 \|\| 类型 \|\| 顺序） |
| 返回值类型 | 一致或是父类方法返回值的子类 | 无关                             |
| 访问权限   | 不严于父类（子类 >= 父类）   | 无关                             |

## 14 super关键字和this关键字的用法

## 答：

### 	super：表示父类对象；只能定义在方法体中；当在子类中调用父类中的父子同名类成员时，通过super关键字区分

### 	this：表示当前类（本类）对象；只能定义在方法体中；当参数变量名与成员字段名一致，且使用参数变量名给成员字段赋值时，通过this关键字区分

### 	当super与this同时使用时，一定先写super

## 15 简述Java中的访问权限修饰符有哪些？作用范围是什么？

## 答：

### 	类的访问权限修饰符：public 		缺省

### 	类成员的访问权限修饰符

| 访问权限修饰符/作用域                   | 本类 | 同包 | 子类、子包 | 任意 |
| --------------------------------------- | ---- | ---- | ---------- | ---- |
| public（公有的）                        | *    | *    | *          | *    |
| protected（受保护的） -- 必须是继承前提 | *    | *    | *          |      |
| 缺省                                    | *    | *    |            |      |
| private（私有的）                       | *    |      |            |      |

## 16 简述Java中常用修饰符有哪些？能够修饰什么？特点？

| 修饰符       | 含义   | 能够修饰           | 特点                                                         |
| ------------ | ------ | ------------------ | ------------------------------------------------------------ |
| static       | 静态的 | 字段、方法、代码块 | 字段和方法直接通过类名.调用；代码块优先主函数加载且只加载一次 |
| final        | 最终的 | 类、字段、方法     | 类不能被继承；字段必须有初始值；方法不能被重写               |
| abstract     | 抽象的 | 类、方法           | 类不能实例化对象；方法没有方法体                             |
| synchronized | 同步的 | 方法、代码块       | 同步操作                                                     |

## 17 简述Java中对象的声明与实例化的区别

## 答：

### 	17-1 个数不同

### 		声明：定义一个

### 		实例化：创建两个

### 	17-2 位置不同

### 		声明：只在栈内存定义

### 		实例化：在栈内存定义地址（对象名），在堆内存存储数据

### 	17-3 是否能够使用

### 		声明：不能使用，会抛出空指针异常

### 		实例化：可以使用

## 18 简述使用封装的好处

## 答：

### 	提高代码安全性

### 	简化代码编写（简化主函数代码编写）

### 	降低类与类之间的耦合度（解耦合）

## 19 简述JavaBean规范

## 答：

### 	类必须使用public作为访问权限

### 	所有的成员字段必须使用private作为访问权限

### 	提供公有的无参构造器

### 	提供所有成员字段对应的公有的get/set方法

## 20 简述使用继承的优缺点和特点

## 答：

### 	优点：

### 		简化代码编写（简化子类代码编写）

### 		提高代码复用性（重用性）

### 	不足：会一定程度上提高类与类之间的耦合度

### 特点：Java中只支持单继承

## 21 简述普通类，抽象类，接口中能够定义哪些类成员

| 比较项             | 普通类               | 抽象类               | 接口                     |
| ------------------ | -------------------- | -------------------- | ------------------------ |
| 定义关键字         | class                | abstract class       | interface                |
| 继承或实现的关键字 | extends              | extends              | implements               |
| 成员字段           | 变量、常量           | 变量、常量           | 常量                     |
| 构造器             | 既能定义，也能实例化 | 只能定义，不能实例化 | 既不能定义，也不能实例化 |
| 成员方法           | 普通方法             | 普通方法、抽象方法   | 抽象方法                 |

## 22 使用多态的好处

## 答：

### 		简化代码编写（简化业务类代码编写）

### 		提高代码复用性

## 23 简述面向对象的特点有哪些？使用面向对象编程的好处？

## 答：

### 		面向对象思想的实质就是封装、继承、多态、抽象的综合应用

### 		好处：

### 				简化代码编写（封装、继承、多态）

### 				提高代码安全性（封装）

### 				提高代码复用性（继承、多态）

### 				降低类与类之间的耦合度（封装）

## 24 单例设计模式的特点

## 答：

### 		私有化构造器

### 		只能在本类实例化对象一次

### 		对外提供获取本类对象的静态方法

## 25 懒汉式和饿汉式的区别

## 答：

### 		懒汉式：多线程操作更安全

### 		饿汉式：单线程操作更快捷

## 26 简述使用匿名操作的优缺点？

## 答：

### 	优点：节省栈内存空间

### 	不足：不利于用户获取

## 27 简述构造器的特点和作用

## 答：

### 	①作用：实例化对象和值传递

### 	②特点：

### 		Ⅰ 构造方法名与类名一致

### 		Ⅱ 构造方法没有返回值部分

### 		Ⅲ 使用new关键字调用

### 		Ⅳ 当类中没有明确定义构造器时，JVM虚拟机会提供一个默认无参构造器；如果定义，则JVM不会提供任何形式的构造器

## 28 简述==与equals的区别

## 答：

### 	①==：只能进行栈内存数据比较

### 				Ⅰ 当进行基本数据类型比较时，比较值是否一致

### 				Ⅱ 当进行引用数据类型比较时，比较的栈内存中地址是否一致

### 		②equals方法：只能进行引用数据类型比较

### 				Ⅰ 当子类没有重写时，调用的是Object类中的equals方法时，与==一致，比较的是栈内存中的地址是否一致

### 				Ⅱ 当子类重写时，则比较引用数据类型实例化后，堆内存中存储的数据值是否一致

## 29 为什么重写equals方法时，必须重写hashCode方法？

## 答：为了提高equals方法的比较效率

## 30 为什么String是不可变的？

## 答：

### 		①在类结构上String被final修饰，表示最终类，因此类结构相对稳定

### 		②由于String底层赋值相当于char[]，而数组一旦创建长度固定，因此String值不可改变

## 31 append方法和+都能够进行字符串拼接操作，区别是什么？

## 		答：操作位置不同 -->> +操作的是堆栈内存；append方法操作的是缓存区

## 32 String、StringBuffer、StringBuilder三个类的特点

## 答：

### 	32-1 三个共同特点

### 		①都是用来操作字符串类型数据的类

### 	②都是被final修饰的类结构稳定的类

### 	32-2 String和StringBuffer

### 			①都是多线程安全的操作

### 			②都是JDK1.0版本开始应用

### 	32-3 StringBuffer和StringBuilder

### 			①都是可变字符串（可变指长度可变）

### 			②都是操作缓存区（缓冲区）

### 	32-4 String类是定长字符串，操作的是堆栈内存

### 	32-5 StringBuilder类是JDK5版本开始应用，单线程操作更快捷

## 33 装饰设计模式和方法重写哪个更好？

## 答：

### 		33-1 方法重写：类与类之间必须是继承关系，必须是对父类已有方法进行功能增强

### 				①好处：当不需要提供增强方法时，可以直接调用父类中定义好的方法

### 				②不足：类与类之间必须是继承关系，耦合度高

### 		33-2 装饰设计模式：类与类之间不一定是继承关系，但是操作的数据类型必须一致；而且增强功能的方法，在原有类中不一定存在

### 			①好处：降低类与类之间的耦合度

### 			②不足：需要调用相同功能的方法，则需要在装饰类中重新定义，比较麻烦

### 	33-3 实际开发中，一般都是继承 + 装饰设计模式组合使用，扬长避短

## 34 简述Java中的异常处理机制是什么？

### 	Java中的异常处理机制是通过Java语言设计好的5个关键字实现的；其中throw表示抛出指定异常类对象；throws表示抛出一个或多个异常类；try表示捕获异常；catch表示打印异常信息和处理异常操作，可以定义多个；finally表示无论是否出现异常都要执行的代码定义代码块

## 35 final和finally关键字的异同点

### 	答：

### 				35-1 相同点：都是修饰符，都表示最终的含义

### 				35-2 不同点：修饰的内容不同

### 								①final：能够修饰类（不能被继承）、成员字段（必须有初始值，且只能赋值一次）、成员方法（不能被重写）

### 								②finally：能够修饰代码块，常用于定义无论是否出现异常都要执行的代码

## 36 集合与数组的异同点

### 	答：

### 			36-1 相同点：

### 					①都是用来存储多个数据的“容器”

### 					② 都可以存储引用数据类型

### 			36-2 不同点：

| 比较项           | 数组                                           | 集合                                 |
| ---------------- | ---------------------------------------------- | ------------------------------------ |
| 存储数据灵活性   | 一旦创建，长度固定，灵活性差                   | 不受长度限制，灵活性强               |
| 存储数据的类型   | 既可以存储基本数据类型，也可以存储引用数据类型 | 只支持引用数据类型存储               |
| 存储数据的安全性 | 只支持同一种类型，更安全                       | 需要使用辅助技术保证数据存储的安全性 |

## 37 单例集合存储数据的特点？以及不同集合实现类底层如何存储数据？

### 	答：

### 				37-1 特点：

### 							①Collection接口：既可以存储重复元素，也可以存储唯一元素；既可以存储有序数据，也可以存储无序数据

### 							②List接口：有序不唯一

### 							③Set接口：无序且唯一

### 							④Queue接口：先进先出的队列式存储

### 				37-2 底层如何存储数据

### 							①ArrayList类：基于动态数组存储，更适合查询操作

### 							②LinkedList类：基于双链表式存储，更适合增删操作

### 							③TreeSet类：基于二叉树存储

### 							④HashSet类：基于哈希码值存储

## 38 Map集合存储数据的特点

### 答：以KEY-VALUE键值对形式存储，为一一对应的映射关系；其中KEY不可以重复，VALUE可以重复

## 39 Java中创建多线程的方式有哪些？如何开启多线程操作？

## 答：

### 	39-1 创建方式：继承Thread类、实现Runnable接口、实现Callable接口

### 	39-2 通过Thread类对象调用start方法开启多线程，并调用run方法执行操作

## 40 每种状态下，多线程所具备的操作权限

| 线程状态         | 权限                     |
| ---------------- | ------------------------ |
| 创建状态         | 只具备生存权             |
| 运行状态         | 既有生存权，又有执行权   |
| 消亡状态         | 没有任何权限             |
| 阻塞（临时）状态 | 只具备生存权，没有执行权 |

## 41 创建状态下与临时状态下的线程生存权是否一致？如果不一致，区别是什么？

### 答：不一致；创建状态下线程生存权，表示线程只被创建，没有开启；而临时状态下的生存权，表示线程已开启，但是由于“抢占”CPU执行权失败，而所拥有的生存权

## 42 处于临时状态下的线程，在JVM中哪个位置存储？进出原则是什么？

### 答：存储在由JVM提供的线程池中，存储原则为先进先出的队列式存储

## 43 sleep方法与wait方法都能够让运行状态下的线程处于临时状态？哪个更好？

## 	答：实际开发中更推荐使用sleep方法，可以通过传参设置“睡眠”时长，到时会自动“苏醒”

## 44 Java中解决多线程安全隐患问题的方式有哪些？区别是什么？

## 答：

### 	44-1 方式：同步代码块、同步函数

### 	44-2 区别：锁的个数不同

### 		①同步代码块有3种锁：本类对象锁（this）、Object锁（obj）、反射机制锁（类	

### 	名.class）

### 		②同步函数只有一种锁：本类对象锁（this）

## 45 简述Java中IO流的分类

## 答：

## 45-1 字符流

### 		字符输入流 -- Reader -- FileReader/BufferedReader

### 		字符输出流 -- Writer -- FileWriter/BufferedWriter

## 45-2 字节流

### 		字节输入流 -- InputStream -- FileInputStream/BufferedInputStream

### 		字节输出流 -- OutputStream -- FileOutputStream/BufferedOutputStream

## 46 字符高效流和字节高效流中是否都提供了高效的操作方法？如果提供，方法的作用是什么？如果没有提供，为什么还要使用？

## 答：

### 		46-1 字符高效流，提供了高效方法，分别是BufferedWriter类提供的换行操作 -- newLine()，体现Java语言的跨平台性，以及BufferedReader类提供的读一行操作 -- readLine()；

### 		46-2 使用高效流的原因是由于操作的是缓冲区，一定程度上缓解堆栈内存操作压力

## 47 什么是序列化和反序列化？

## 答：

### 47-1 序列化：使用指定的技术，将对象中的数据存储到指定文件中或通过网络上传到指定位置上

### 47-2 反序列化：使用指定的技术，将指定文件或网络地址上的数据下载到指定的对象中存储

## 48 传递基本数据类型和引用数据类型的异同点

### 48-1 相同点：都是在栈内存中完成参数传递

### 48-2 不同点：

### 	①参数数据传递形式不同

### 		Ⅰ 基本数据类型传递的是指定的值

### 		Ⅱ 引用数据类型传递的是地址

### 	②参数数据引用的位置不同

### 		Ⅰ 基本数据类型在栈内存中完成引用

### 		Ⅱ 引用数据类型在堆内存中完成引用

## 49 简述继承Thread类和实现Runnable接口的优缺点

### ①继承Thread类

### 	Ⅰ 优点：直接调用父类中的所有操作多线程的方法

### 	Ⅱ 不足：提高类与类之间的耦合度

### ②实现Runnable接口

### 	Ⅰ 优点：避免Java中单继承的局限性

### 	Ⅱ 不足：需要先与Thread类建立关联后，才能调用方法完成对线程的操作